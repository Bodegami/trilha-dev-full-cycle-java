COMANDOS BÁSICOS:

docker --version == imprime a versao do Docker instalada

docker ps == imprime os containers em execucao

docker ps -a == imprime todos os containers (em execucao e os parados)

docker run hello-world == baixa a imagem e cria um container com a imagem informada (hello-world)

docker run -i ubuntu bash == baixa a imagem do ubuntu, cria o container com a imagem e abre o terminal bash interativo

docker exec -it "nome_container" bash == acessa um container, integrando o terminal e abilitando a execucao de comandos

exit ou CTRL + D == sai de um container docker

docker start id_container/ nome_container == inicia um container parado

docker stop id_container/ nome_container == interrompe a execucao do container informado.

docker run -it --rm ubuntu:latest bash == baixa a imagem do ubuntu, cria o container com a imagem, abre o terminal bash interativo e exclui o container ao sair.

docker run -d -p 8080:80 nginx == baixa a imagem nginx, cria o container da imagem redirecionando a porta do container 8080 para a porta local 80 e sem travar o terminal.

docker stop id_container/ nome_container == interrompe a execucao do container informado.

docker rm id_container/ nome_container == exclui um container parado

docker rm id_container/ nome_container -f == força a exclusao de um container mesmo que em execucao

docker run --name meu-ubuntu ubuntu == baxa a imagem ubuntu, cria um container da imagem com o nome meu-ubuntu

docker exec id_container/ nome_container comando_bash == executa um comando informado no container informado

docker run -p 8080:80 -v ~/Projects/fullcycle3/docker/html:/usr/share/nginx/html nginx == baixa a imagem do ngix, cria um container e faz um "bind mount" do volume local para um volume do container

docker volume create nome_volume == cria um volume local com o nome informado

docker volume inspect nome_volume == imprime o detalhamento dos dados do volume informado

docker run --mount type=volume,source=meuvolume,target=/app nginx == baixa a imagem nginx, cria o container da imagem atachando o volume local "meuvolume" no container. 
A vantagem é que podemos criar varios containers compartilhando o mesmo volume.

docker run -v meuvolume:/app nginx == baixa a imagem nginx, cria o container da imagem e assim como --mount, -v atacha um volume local ao container no diretorio informado.

docker volume prune == remove todos os volumes locais que não estão sendo utilizados e informa o espaço em disco liberado.

docker images == imprime as imagens no computador.

docker pull nome_imagem:versao_da_imagem == baixa a versao da imagem informada. Caso a versao seja omitida, ele vai baixar a ultima versao disponivel.

docker rmi nome_imagem:versao_da_imagem == exclui a imagem informada.

docker build -t usuario/nome_imagem:versao_imagem . == cria uma imagem a partir da versao informada na raiz do diretorio. Para esse comando funcionar é necessário um dockerfile na raiz do diretorio.
A vantagem dessa abordagem é que podemos criar uma imagem personalizada.

docker ps -a -q == imprime apenas os id's de todos os contaners

docker rm $(docker ps -a -q) -f == exclui todos os container pelos id's. Note que são duas instrucoes dentro de um comando.

docker run --rm usuario/nome_imagem:versao_imagem echo "oi" == cria um container da imagem informada e substitui comando inicial do container pela instucao informada e executa.

docker push usuario/nome_imagem:versao_imagem === faz o push da imagem para o docker hub do usuario informado







DOCKERFILE:

As principais tags do dockerfile são:

- FROM: é onde informamos a imagem e versao
- USER: é o usuário que queremos definir com padrao no container, lembrando que o mesmo já deve ser criado no container. Caso esse parametro seja omitido, por padrao o docker vai usar o usuario root do container.
- WORKDIR: é o diretorio padrao ao acessar o container
- RUN: executa um ou mais sequências de comandos como apt-get install vim e etc
- COPY: copia uma pasta do ambiente local para um diretorio dentro do container.
- CMD: executa um comando dentro do container. Esse comando pode ser substituido por um parametro hora da criacao do container
- ENTRYPOINT: executa um comando dentro do container. É um comando fixo que não pode ser substituido, mas pode ser combinado com um comando variavel.
- ENV: envia variaveis de ambiente para o container.
- EXPOSE: expoe uma porta do container. Ainda assim é necessário fazer o bind com uma porta local para acessar esta porta.


NETWORK:
- tipos de network:
    - bridge: é a network default. Ela permite um container se conectar com outro
    - host: permite uma conexao entre o container e o host. Fica na mesma rede do computador.
    - overlay: cria uma rede para que varias instancias do mesmo container possam se comunicar.
    - maclan: simula um um mac-adress de uma máquina real.
    - none: cria uma rede isolada para o container

- quando não especificamos o tipo de network, por padrão o docker utiliza o tipo bridge





FLAGS:

-i == modo interativo, ele anexa o seu terminal com o do container de forma que é possível acessar o container

-t == TTY, permite digtar coisas no terminal

-it == modo interativo que anexa o terminal local com o do container e possibilita a digitação de comandos

-a == exibe instâncias, imagens e containers parados 

rm == remove um processo, container, imagem, volume e etc

-p 8080:9000 == publica a porta 8080 do container para a minha porta local 9000 (redireciona de 8080 para 9000)

-d == executa o script e libera o terminal. É D de detached

-f == força a execucao de um processo

--name meu-container == atribui o nome informado ao container

-v rota_local:rota_do_container == cria um "bind mount" que é um volume local que será atachado ao container em execucao. É importante lembrar que ao excluir este container, esse volume não sofrera nenhum impacto.

--mount  type=bind, source="$(pwd)"/html, target=/usr/share/nginx/html == tem a mesma funcionalidade do -v, porém é mais atual e explicito. Além disso, o --mount valida se a pasta ou arquivo informado existe, já o -v cria o arquivo ou pasta caso ele nao exista.





TIPS:

- ALTERANDO A PAGINA PRINCIPAL DE CONTAINER NGINX:
    - acessamos o container com terminal bash: docker exec -it id_container/ nome_container bash
    - atualizamos o cache do apt-get : apt-get update
    - instalamos o editor de textos vim: apt-get install vim
    - acessamos o diretorio do arquivo principal: cd /usr/share/nginx
    - executamos o editor de texto do arquivo index.html: vim index.html
    - abilitamos o modo edicao: pressionar tecla "i". final do terminal de aparecer INSERT indicando que o modo edicao está ativo
    - alteramos o arquivo: alteramos da forma que quisermos
    - saindo do modo edicao: pressionar a tecla ESC para sair do modo edicao. A palavra INSERT deve sumir do terminal
    - salvando o arquivo: pressionamos as teclas ":w" para salvar o arquivo. O W é de write
    - saindo do vim: pressionamos as teclas ":q" para sair do vim. O Q é de quit.
    
    
- EXIBINDO INFORMACOES DO CONTAINER: 
    - acessamos o container com terminal bash: docker exec -it id_container/ nome_container bash
    - executamos o comando: uname -a. As informacoes serao printadas na tela
    
- VERIFICANDO O DOCKERFILE DE UMA IMAGEM:
    - acessamos o repositorio da imagem no docker hub
    - acessamos a versao que buscamos e seremos redirecionados para a github da imagem
    - no repositorio do gitub é possivel acessar o dockerfile e verificar todas as instrucoes.
  
- Linux tips:
    - echo $(pwd) == imprime o diretorio atual
    - uname -a == imprime a versao linux
    
- Sobre o arquivo docker-entrypoint.sh:
    - o arquivo docker-entrypoint.sh tem uma instrucao "exec '$@". 
    - essa instrucao indica que ele aceita qualquer instrucao apos a sua execucao.
    - exemplo: ./docker-entrypoint.sh echo "hello"
    - ele ira executar toda logica dentro do arquivo docker-entrypoint.sh e depois ira imprimir no console o "hello"